//   Copyright (c) 2018 Contributors to the Eclipse Foundation
// 
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

:revnumber: 0.1
:revdate: 2018-03-27
:revremark: Specification
:version-label!:
:sectanchors:
:doctype: book
:license: Apache License v2.0
:source-highlighter: coderay
:toc: left
:toclevels: 4
:sectnums:
ifdef::backend-pdf[]
:pagenums:
endif::[]
:icons: font
:sourcedir: ../../../../api/src/main/java


[[long-running-actions]]
= Eclipse MicroProfile LRA

include::license-alv2.asciidoc[]

[[introduction]]
== Introduction

The proposal introduces annotations and APIs for services to coordinate
long running activities whilst still maintaining loose coupling and
doing so in such a way as to guarantee a globally consistent outcome
without the need to take locks on data.

[[motivation]]
== Motivation

In a loosely coupled service based environment there is sometimes a need
for different services to provide consistency guarantees. Typical
examples include:

* order processing involving three services (take order, bill customer,
ship product). If the shipping service finds that it is out of stock
then the customer will have been billed with no prospect of receiving
his item.
* an airline overbooks a flight which means that the booking count and
the flight capacity are inconsistent.

There are various ways that systems overcome such inconsistency but it
would be advantageous to provide a generic solution which handles
failure conditions, maintains state for those flows that span long
periods of time and ensures that remedial activities are called
correctly.

Traditional techniques for guaranteeing consistency in distributed
environments has focused on XA transactions where locks may be held for
long periods thereby introducing strong coupling between services and
decreasing concurrency to unacceptable levels. Additionally, if such a
transaction aborts then valuable work which may be valid will be rolled
back. In view of these issues an alternative approach is desirable.

Goals

* support long running actions
* no strong coupling between services
* allow actions to finish early
* allow some parts of a computation to be cancelled without
  affecting other parts of the computation (aka nested activities)
* guarantee execution of compensating actions if a business activity
  is cancelled

[[proposed-solution]]
== The solution

We propose a compensation based approach in which participants make
changes visible but register a compensatory action which is performed if
something goes wrong. We call the model LRA (short for Long Running
Action) and is based on work done within the
https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=ws-caf[OASIS
Web Services Composite Application Framework Technical Committee],
namely
https://www.oasis-open.org/committees/document.php?document_id=12794[Long
Running Action transaction model], but updated to be more suited for use
in microservice based architectures.

In the LRA model, an activity reflects business interactions: all work
performed within the scope of an activity is required to be
compensatable and the protocol ensures that when the activity terminates
then either all work will be accepted or will be compensated, ie
the activity’s work is either performed successfully or undone. For
example, when a user reserves a seat on a flight, the airline
reservation centre may take an optimistic approach and actually book the
seat and debit the user's account, relying on the fact that most of
their customers who reserve seats later book them; the compensation
action for this activity would be to un-book the seat and credit the
user’s account. How services perform their work and ensure it
can be undone if compensation is required are implementation choices and
is not exposed to the LRA model which simply defines the triggers for
compensation actions and the conditions under which those triggers are
executed. In other words, the LRA protocol is concerned only with
ensuring participants obey the protocol necessary to make an activity
compensatable and is intended to better model interactions between
microservices. Issues such as isolation of services between
potentially conflicting activities and durability of service work are
assumed to be implementation decisions. Although this may result in
non-atomic behaviour for the
overall business activity, other activities may be started by the
service to attempt to compensate in some other manner.

[[the-model]]
=== The Model

The model concerns participants (aka compensators), a logical coordinator
and a client. A client starts a new LRA via an annotation
or an API call which results in the creation of a new LRA.
When a business service does work that may have to be later compensated
it enlists a participant with the LRA which, when the client later closes
or cancels the LRA, operates on behalf of the service to undo the work
the service performed within the scope of an LRA or to compensate for the
fact that the original work could not be completed. The following diagram
shows the sequence of events that this model implies:

:imagesdir: images
.LRA Protocol Sequence
image::lra.png[align="center"]

The participants will be invoked in the following way when the LRA terminates:

* *Success*: the client has closed the LRA and the activity has completed
successfully. All participants (including ones enlisted with any LRAs nested
under the top level LRA) that are associated with the LRA
are informed that the activity has terminated and they can perform any
necessary cleanup.
* *Fail*: the client has cancelled the LRA and the activity has completed
unsuccessfully. All participants
that are registered with the LRA will be invoked to perform compensation
in the reverse order
footnote:[Note that calling participants in reverse order does not guarantee that
          the compensation actions will be performed in strict sequential order
          since participants are allowed to indicate that the compensation is in
          progress and will complete at some future time. Furthermore a
          participant can indicate that it failed to compensate, or could be
          unavailable in which case it will be periodically retried (out of
          order).].
The LRA forgets about all participants
that indicated they operated correctly. Otherwise, compensation may be
attempted again (possibly after a period of time) or alternatively a
compensation violation has occurred and must be logged. Each service is
required to log sufficient information in order to ensure (with best
effort) that compensation is possible even in the event of failures.
Note that compensation violations include the case where a participant
completes when asked to compensate.

Similar remarks apply to completion violations.

Interposition (nesting) and reliably storing the state of participants
allows the system to drive a consistent view of the outcome and to take
recovery actions in the event of failure, but allowing
always the possibility that recovery isn’t possible which must be logged
or flagged for the administrator and manual intervention may be necessary
to restore an application’s consistency.

A LRA and a participant both follow similar state models (with slightly
different wording to indicate that the states refer to the LRA as a whole
rather than to individual participants):

* `Active`: the LRA exists and has not been asked to close or cancel yet
* `Cancelling`: the LRA is currently being cancelled
* `Cancelled`: the LRA has successfully cancelled
* `FailedToCancel`: at least one participant was not able to
compensate
* `Closing`: the LRA is currently being closed
* `Closed`: the LRA has closed
* `FailedToClose`: at least one participant was not able to complete

:imagesdir: images
[[lra-state-model]]
.LRA State Model
image::lra-state-model.png[align="center" link="lra-state-model"]

And the participants state model has the following states:

* `Active`: the participant exists and has not been asked to compensate
or complete yet
* `Compensating`: a participant is currently compensating for the work
that it performed during the LRA.
* `Compensated`: a participant has successfully compensated for the work
that it performed during the LRA.
* `FailedToCompensate`: the participant was not able to compensate for the
work it did during the LRA.
* `Completing`: the participant is tidying up after being told to
complete.
* `Completed`: the participant has confirmed that it has finished
tidying up.
* `FailedToComplete`: the participant was unable to tidy-up some resources
it allocated during the LRA.

When a participant joins an LRA it is said to be enlisted but it does not
enter the state model until it receives a complete or compensate message:

:imagesdir: images
[[participant-state-model]]
.Participant State Model
image::participant-state-model.png[align="center" link="participant-state-model"]

Note that when the LRA has been asked to cancel it enters the state `Cancelling`
and will eventually ask all registered participants to enter the state
`Compensating`. A similar remark applies to the LRA state `Closing` and participant state
`Completing`.

The participant can be enlisted only once per LRA instance. When participant
is about to be enlisted multiple times (e.g. client calls the same `@LRA` method
several times) the follow-up enlistments of such participant MUST be ignored.

Different usage patterns for LRAs are possible, for example LRAs may be
used sequentially and/or concurrently, where the termination of one LRA
signals the start of some other unit of work within an application.
Additionally, speculative execution of work can be supported by nesting
LRAs, some of which can be cancelled independently of the parent LRA
whilst others are closed based on the outcome of other LRAs.
LRAs are units of compensatable work and an application may
have as many such units of work operating simultaneously as it needs to
accomplish its tasks. Furthermore, the outcome of work within LRAs may
determine how other LRAs are terminated. An application can be
structured so that LRAs are used to assemble units of compensatable work
and then held in the active state while the application performs other
work in the scope of different (concurrent or sequential) LRAs. Only
when the right subset of work (LRAs) is arrived at by the application
will that subset be confirmed; all other LRAs will be told to cancel
(complete in a failure state).

In the rest of this proposal we specify an API for
controlling the life cycle of and participation in LRAs:

[[java-annotations-for-lras]]
=== Java Annotations for LRAs

Support for the proposal in MicroProfile is primarily based upon the use
of Java annotations for controlling the life cycle of LRAs and of participants, ie
the service developer annotates JAX-RS resources to specify how
LRAs should be controlled and when to _enlist a class_ as a participant.

==== Quick overview of annotations

The definitive documentation for how the annotations affect the behaviour of a running
program is the javadoc and this specification should be read in conjunction with it.
The annotations are defined in the
https://github.com/eclipse/microprofile-lra/tree/master/api/src/main/java/org/eclipse/microprofile/lra/annotation[org.eclipse.microprofile.lra.annotation]
package:

[cols="1,4"]
|===
| Annotation | Description

| https://github.com/eclipse/microprofile-lra/tree/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/LRA.java#L30[@LRA]
  | Controls the life cycle of an LRA.
| https://github.com/eclipse/microprofile-lra/tree/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/Compensate.java#L29[@Compensate]
  | Indicates that the method should be invoked if the LRA is cancelled.
| https://github.com/eclipse/microprofile-lra/tree/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/Complete.java#L29[@Complete]
  | Indicates that the method should be invoked if the LRA is closed.
| https://github.com/eclipse/microprofile-lra/tree/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/Forget.java#L29[@Forget]
  | Indicates that the method may release any resources that were allocated for this LRA.
| https://github.com/eclipse/microprofile-lra/tree/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/Leave.java#L29[@Leave]
  | Indicates that this class is no longer interested in this LRA.
| https://github.com/eclipse/microprofile-lra/tree/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/Status.java#L30[@Status]
  | When the annotated method is invoked it should report the status.
|===

Briefly, these annotations are used as follows:

The application annotates some JAX-RS resource method with `@LRA` which determines whether the
method will run in the context of an LRA. Generally, if a method starts a new LRA it will
be closed when the method finishes execution (but elements of the annotation facilitate
full control over the LRA lifecycle).

If execution is to run with an active LRA and the associated class contains other methods
annotated with `@Compensate` and `@Complete` then these methods will be associated with
the active LRA. They will be invoked when the LRA is subsequently cancelled or closed.
If the participant successfully compensates or completes then it may forget about the LRA.
Otherwise it should remember that it is still associated with the LRA and it MUST report
the status of the association using values in the
https://github.com/eclipse/microprofile-lra/tree/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/ParticipantStatus.java[`ParticipantStatus`]
enum according to the participant state model defined earlier.
It can report the status directly from the `@Compensate` or `@Complete` methods if they
are idempotent, otherwise it MUST provide a method annotated with `@Status`.

If the participant is no longer associated with the LRA (because it has successfully
compensated or completed or because it has left the LRA) it MAY return the
`404 Not Found` HTTP status code from any of these methods.

If the participant knows it will never be able to compensate or complete then it MUST remember
that it could not until explicitly told that it can clean up by providing a method annotated with `@Forget`
(the requirement is marked MUST because message delivery is not guaranteed in a distributed system).

If multiple methods are annotated with the same annotation an arbitrary one will be chosen.

[[lra-context]]
==== The LRA Context

When a method is invoked in the context of an LRA its identifier MUST be made
available to the business logic. This LRA is referred to as the `active context`.
For JAX-RS resource methods the identifier is made available via request and
response headers which the business method can obtain using standard JAX-RS mechanisms,
ie `@Context` or by injecting a JAX-RS header param with the name specified by
the Java constant `LRA_HTTP_CONTEXT_HEADER` as defined <<source-LRA, in the LRA annotation class>>.
This header is referred to as the `context header`.

The implementation MUST propagate the `active context` on outgoing JAX-RS
requests.
footnote:[issue #35 (Do not define JAX-RS annotations on `@Compensate` methods)
removes the requirement for some methods to be JAX-RS resources. The resolution
of that issue should ensure the context is still available to business logic.

If an LRA is propagated to a resource that is not annotated with any of the
annotations defined in this specification then the LRA will not be made
available to the invoked method. However, any outgoing JAX-RS invocations
made during the execution of the method will still carry the original context.

The user is allowed to manually assign the `context header` on JAX-RS requests
and responses:

===== Setting the context on outgoing JAX-RS requests

If the context is set on an outgoing JAX-RS request then it becomes the `active
context` for that invocation. When the invocation returns the context that
was active before the invocation once again becomes the active context.

===== Setting the context on JAX-RS responses

A resource is allowed to manually set the `context header` on JAX-RS responses.
Users should be careful when using this capability since this context will
overwrite whatever the implementation has set.

[[java-annotations]]
==== Starting and Ending LRAs

[[controlling-the-life-cycle-of-an-lra]]
The life cycle of an LRA is controlled via the <<source-LRA,LRA annotation>>
(https://github.com/eclipse/microprofile-lra/tree/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/LRA.java#L30[@LRA]).

The annotation SHOULD be applied to JAX-RS annotated methods otherwise
it MAY have no effect. It determines whether or not the annotated method
will run in the context of an LRA and controls whether or not:

- any incoming context should be suspended and if so if a new one should be started.
- to start a new LRA.
- to end any LRA context when the method ends.
- to throw an exception if there should be an LRA present on method entry.
- to throw an exception if the method returns particular HTTP status codes.
- to enlist the class as a participant of the LRA.

If the method is to run in the context of an LRA and the annotated class
also contains a method annotated with `@Compensate` then the class
(aka participant or compensator) will be enlisted with the LRA.
This means that before starting the method the implementation must be able
to guarantee that participant has been or will eventually be registered
with the LRA. The practical consequence of this requirement is that the
implementation must durably record that the participant is enlisted before
letting the business invocation proceed.
Enlisting with an LRA means that the bean will be notified when the current LRA is
subsequently cancelled or closed (if the class also contains a method
annotated with `@Complete`). In addition the implementation should generate a
URI for this participant and make it available to the business logic via a JAX-RS
header param with name defined by the Java constant `LRA_HTTP_RECOVERY_HEADER` as defined
<<source-LRA, in the LRA annotation>>
(https://github.com/eclipse/microprofile-lra/tree/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/LRA.java[github link]).
The header should also be made available to the application whenever any
of the participant callbacks are invoked. The application is free to ignore
this header.
Enlisting in an LRA is explained in more detail
<<compensating-activities,in a later section>> of this document.

It is the `LRA.Type` element of the LRA annotation that provides fine grained control over the
LRA for the duration of the execution of the annotated method and the reader
should consult the javadoc for details.

Bear in mind that the LRA annotation is expected to be used with JAX-RS
which expects the `Response` being the method return type.
If a `200 OK` response is to be returned then the method can
return any data type that it desires.
The specification does not discuss what happens when
an uncaught exception is thrown from the `@LRA` annotated method.
It's up to the framework to transform the thrown exception
to the JAX-RS `Response` error status code.
It's a usual practice the `RuntimeException` to be transformed
to the `5xx` `Response` status code.

The LRA annotation can be used to control whether or not the LRA context should
be closed when the method finishes (see the javadoc for the `LRA#end()`
element for details.

The LRA annotation can be used to control whether or not the LRA context should
be cancleed when the method finishes (see the javadoc for the `LRA#cancelOn()`
and `cancelOnFamily` elements for details).

When an LRA is present its identifier MUST be made available to
the business logic via request and response headers as described earlier
(using a header name specified in the Java constant `LRA_HTTP_CONTEXT_HEADER`).

The following is a simple example of how to start an LRA and how to receive
a notification when the LRA is later cancelled (`@Compensate` is invoked)
or closed (`@Complete` is invoked):

[source,java]
----
@Path("/")
@ApplicationScoped
public class SimpleLRAParticipant
{
    @LRA(LRA.Type.REQUIRES_NEW)
    @Path("/cdi")
    @PUT
    public void doInTransaction(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) String lraId)
    {
        /*
         * Perform business actions in the context of the LRA identified by the
         * value in the injected JAX-RS header. This LRA was started just before
         * the method was entered (REQUIRES_NEW) and will be closed when the
         * method finishes at which point the completeWork method below will be
         * invoked.
         */
    }

    @Complete
    @Path("/complete")
    @PUT
    public Response completeWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) String lraId,
                                 String userData)
    {
        /*
         * Free up resources allocated in the context of the LRA identified by the
         * value in the injected JAX-RS header.
         *
         * Since there is no @Status method in this class completeWork MUST be
         * idempotent and MUST return the status.
         */
         return Response.ok(ParticipantStatus.Completed.name()).build();
    }

    @Compensate
    @Path("/compensate")
    @PUT
    public Response compensateWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) String lraId,
                                   String userData)
    {
        /*
         * The LRA identified by the value in the injected JAX-RS header was
         * cancelled so the business logic should compensate for any actions
         * that have been performed while running in its context.
         *
         * Since there is no @Status method in this class compensateWork MUST be
         * idempotent and MUST return the status
         */
         return Response.ok(ParticipantStatus.Compensated.name()).build();
    }
}
----

The example also shows that when an LRA is present its identifier can be obtained
by reading the request headers.

The next example demonstrates how to start an LRA in one method and close
it in a different method using the `LRA#end` element.
It also shows how to configure the LRA to be automatically cancelled if the business method
returns the particular HTTP status codes identified in the `cancelOn` and
`cancelOnFamily` elements:

[source,java]
----
  @LRA(value = LRA.Type.REQUIRED, // if there is no incoming context a new one is created
       cancelOn = {
           Response.Status.INTERNAL_SERVER_ERROR // cancel on a 500 code
       },
       cancelOnFamily = {
           Response.Status.Family.CLIENT_ERROR // cancel on any 4xx code
       },
       end = false) // the LRA will continue to run when the method finishes
  @Path("/book")
  @POST
  public Response bookTrip(...) { ... }

  @LRA(LRA.Type.SUPPORTS, // if there is an incoming context then it used as the active context
       end = true) // end the LRA started by the bookTrip method
  @Path("/confirm")
  @PUT
  public Booking confirmTrip(Booking booking) throws BookingException { ... }
----

The `end = false` element on the bookTrip method forces the LRA to continue running when
the method finishes and the `end = true` element on the confirmTrip method forces the LRA
(started by the bookTrip method) to close the LRA.

[[compensating-activities]]
==== Compensating Activities

As remarked elsewhere, the LRA specification attempts to enforce some of the traditional
guarantees provided by transactional systems such as atomicity (all or nothing)
whilst relaxing others, such as isolation of work amongst participants. The characteristic
of strong consistency of data (the system can only be observed to transition between
consistent states) is also relaxed in favour of what is referred to as `eventual
consistency`. The LRA specification ensures atomicity and eventual consistency by
placing certain requirements on the entities that participate in the protocol
which we now discuss (further details of these responsibilities can be found in
the javadoc for the participant annotations).

The application developer indicates which method to use for a compensating
activity by marking it with the `@Compensate` annotation.
Whenever the associated resource is invoked in the context of
an LRA the method corresponding to this `@Compensate` method MUST be enlisted with
the LRA: enlistment means that if the LRA is subsequently cancelled then the compensation
method MUST be invoked.

The specification does not mandate when this method is invoked
but it does guarantee that it will eventually be called (this is the precise
meaning of the term `eventual consistency` as used in this specification).
Under failure conditions the system will keep retrying until it is certain that the
participant has been successfully notified.

The LRA model is quite flexible in how business methods perform compensations.
If a compensating activity is brief then the synchronous model may be appropriate:

[source,java]
----
    @Compensate
    @Path("/compensate")
    @PUT
    public Response compensatePreviousAction(
            @HeaderParam(LRA_HTTP_CONTEXT_HEADER) String lraId) {
        getActivity(lraId).setCompensated();

        return Response.ok();;
    }
----

On the other hand, the compensating logic may involve concerted activities,
perhaps even compensating in the context of another LRA. In this case the
protocol accomodates a more decoupled mode of operation - the following example
shows how a compensating activity can be started in the background:

[source,java]
----
    @Compensate
    @Path("/compensate")
    @PUT
    public Response compensatePreviousAction(
            @HeaderParam(LRA_HTTP_CONTEXT_HEADER) String lraId) {
        ActivityClient client = getActivity(lraId).getResourceForCompensation();
        String backgroundActivity = client.compensate(lraId);
        ...
        return Response.accepted().build();
    }
----

Here the business logic reports that the compensation is in progress by returning
the `202 Accepted` HTTP status code. Of course the system must still guarantee
atomic outcomes so the participant is responsible for reporting when it has
finished compensating: it may do this by allowing the compensation method
to be called multiple times in the context of the same LRA until the final state
is known. But if the method `compensatePreviousAction` should not be called a
second time (ie it is not idempotent) then the participant has the option of
reporting its` progress using the `@Status` annotation:

[source,java]
----
    @Status
    @Path("/status")
    @GET
    public Response status(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) String lraId) {
        if (isFinished(lraId))
            return Response.ok().entity(ParticipantStatus.Compensated).build();
        else
            return Response.ok().entity(ParticipantStatus.Compensating).build();
    }
----

Notice that in this code example the participant is reporting progress using
the appropriate `ParticipantStatus` enum according to the <<participant-state-model,the
participant state model>>.

But what if the business logic is unable to compensate for a previous action?
In this case the participant must remember that it was unable to compensate
by reporting `FailedToCompensate` either via the compensate method, for example

[source,java]
----
    @Compensate
    @Path("/compensate")
    @PUT
    public Response compensatePreviousAction(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) String lraId) {
        if (isFailed(lraId))
              return Response.ok().entity(ParticipantStatus.FailedToCompensate).build();
        ...
    }
----

or it can report the failure via the `@Status` method:

[source,java]
----
    @Status
    @Path("/status")
    @GET
    public Response status(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) String lraId) {
        if (isFailed(lraId))
            return Response.ok().entity(ParticipantStatus.FailedToCompensate).build();
        ...
    }
----

In the successful case the participant SHOULD clean up any resources it allocated in the
context of the LRA. Any requests (including the current one) made in the context of the
same LRA MAY return a `404 Not Found` status code.

In the failure case the participant is responsible for remembering that it failed until
it is explicitly told that it can clean up via the `@Forget` method:

[source,java]
----
    @Forget
    @Path("/forget")
    @DELETE
    public Response forget(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) String lraId) {
        if (isFailed(lraId))
            cleanupResources(lraId);

        return Response.ok().build();
    }
----

The resource class MAY also contain a method marked with the `@Complete` annotation. 
If such a method is present then the method MUST be invoked when the associated LRA 
is closed. Again, the specification does not MANDATE when the method is called, 
just that it will eventually be invoked. Typically the resource would use this call 
to perform any clean up actions. The method is optional since such clean up actions 
may not be necessary, for example consider a system that just tracks hotel reservations 
and has operations for booking a room or cancelling the reservation (`@Compensate`). 
Since this system is passive, once a room is booked, it does not make any difference 
if the LRA is completed or not: the room will be unavailable for others. If it receives 
a call to `@Compensate` then it will free the room. But it won't do anything on 
`@Complete`.

If the participant successfully compensates or completes then it may forget about
the LRA. Otherwise it should remember that it is still associated with the LRA and
it MUST report the status of the association using one of the values in the
`ParticipantStatus` enum according to the <<participant-state-model,the
participant state model>>. If the compensation and completion methods are not
idempotent then there MUST be a method annotated with `@Status` which reports the
status. Otherwise the compensation and completion methods should return the status.
If the participant is no longer associated with the LRA (because it has successfully
compensated/completed) it MAY return the `404 Not Found` HTTP status code from any
of these methods. If it knows it will never be able to compensate or complete then
it MUST remember the fact until explicitly told that it can clean up by providing
a method annotated with `@Forget` (the requirement is marked MUST because message
delivery is not guaranteed in a distributed system).

If there is no `@Status` then the `@Compensate` or `@Complete` methods will continue
to be invoked until the implementation knows it has the final status.

If the `@Compensate` or `@Complete` annotation is present on multiple methods
then an arbitrary one is chosen. 

The javadoc for the <<source-Compensate,Compensate annotation>> provides
more details about this annotation. 

Similarly, the javadoc for the <<source-Complete,Complete annotation>>
provides details about the `@Complete` annotation. 

==== Participant marker annotations method signatures

The participant marker annotations are annotations that allow users to mark a method 
for the execution by the LRA implementation according to the <<participant-state-model,
the participant state model>>. These annotations are: 

* `@Compensate` -- a method to be executed when the LRA is cancelled
* `@Complete` -- a method to be executed when the LRA is closed
* `@Status` -- a method that allow user to state status of the participant with regards 
to a paricular LRA
* `@Forget` -- a method to be executed when the LRA allows participant to 
clear all associated information

This specification differentiates two types of participant method definitions -- 
methods associated with the JAX-RS resource method or the methods which are not 
bound to JAX-RS. 

[[jaxrs-participant-methods]]
===== JAX-RS participant methods

The following table presents expectations that are placed on individual participant 
annotations when associated with JAX-RS resource methods:

[[jaxrs-response-table]]
|===
| Annotation | HTTP method | Expected status codes | Response

| `@Compensate`
| PUT
| 200, 202, 404, 412
| <<source-ParticipantStatus,ParticipantStatus>>

| `@Complete`
| PUT
| 200, 202, 404, 412
| <<source-ParticipantStatus,ParticipantStatus>>

| `@Status`
| GET
| 200, 202, 404, 412
| <<source-ParticipantStatus,ParticipantStatus>>

| `@Forget`
| DELETE
| 200, 404, 412
| no expectations

|=== 

If the participant annotation is not accompanied by an associated JAX-RS HTTP method 
annotation according to the <<jaxrs-response-table,table above>>, the error SHOULD be reported using a JAX-RS 
exception mapper that maps to a `412 Precondition Failed` HTTP status code.
If the annotated method returns an unexpected HTTP status code the implementation MAY
invoke the same method again.

Users are allowed to reuse existing JAX-RS endpoints for participant methods definitions. 
In this case, LRA implementation MUST ensure that invoking these methods outside of the 
implementation of the LRA specification will not influence any running LRA.

[[non-jaxrs-participant-methods]]
===== Non-JAX-RS participant methods

When the participant annotations are applied to the non-JAX-RS resource methods they 
MUST adhere to these predefined signatures:

* *Return type*: 
** `void`: successfull execution is mapped to `Compensated` or `Completed` participant statuses, 
 error execution is handled by <<non-jax-rs-exceptions, exceptions>> thrown in the participant method
*** not applicable for `@Status` participant methods
** <<source-ParticipantStatus,ParticipantStatus>>
** `javax.ws.rs.core.Response`: handled similarly as for 
<<jaxrs-participant-methods, JAX-RS participant methods>>
** `java.util.concurrent.CompletionStage`: with the parameter of any of the previously 
defined types
* *Arguments*: up to 2 arguments in this order:
** `java.net.URI` or `java.lang.String`: representing current LRA context identification
** `java.net.URI` or `java.lang.String`: representing potential parent LRA context identification

Declaring more than two arguments, different types of arguments or different return type 
for any non-JAX-RS method annotatated with the participant marker annotation MUST result 
in the deployment time `InvalidLRAParticipantDefinitionException`. 
Please note that both arguments are optional but the order is required. This means that 
if only one argument is provided this argument will contain the value of the current 
active LRA context (not the parent LRA context in case of nested LRA).

Examples of valid signatures:

[source,java]
----
@Compensate
public void compensate(URI lraId, URI parentId)

@Compensate
public void compensate(String lraId, URI parentId)

@Complete
public Response complete(URI lraId)

@Complete
public Response complete(String lraId)

@Status
public CompletionStage<ParticipantStatus> status(URI lraId)

@Status
public CompletionStage<ParticipantStatus> status(String lraId)
----

Examples of invalid signatures:

[source,java]
----
@Compensate
public String compensate(URI lraId) // invalid return type

@Forget
public void forget(URI lraId, URI parentId, String additional) // too many arguments
----

[[non-jax-rs-exceptions]]
If any of the described methods throws an exception, we distinguish two cases depending 
on the exception type:

* `WebApplicationException` -- the exception is mapped to the HTTP response it carries 
and then handled as defined in the section 
<<jaxrs-participant-methods, JAX-RS participant methods>>
* any other exception 
** @Compensate and @Complete - results into `FailedToCompensate` or `FailedToComplete`  
participant states
** @Status and @Forget - as the participant may have already compensated (or completed) 
or may in the process of compensation (completion) the exception in these methods should 
result into failure condition (in JAX-RS this condition is represented by 
500 return HTTP status code) which individual interpretation is left further unspecified.

In case the implementation of this specification exposes non-JAX-RS participant methods 
to be able to call them externally (e.g. the HTTP proxy) then it MUST protect every 
exposed method from unauthorized access. The specific security details are not specified.

[[eventual-compensations]]
==== Eventual compensations

[[async-compensators]]
If the resource cannot perform a compensation activity
immediately the `@Compensate` method SHOULD do one or more of the following:

- return `ParticipantStatus.Compensating`
- return a `202 Accepted` HTTP status code
- mark the method as a JAX-RS asynchronous method (using the
  `javax.ws.rs.container.Suspended` annotation).

The `@Status` method, if present, MUST report the progress of the compensation.

Similarly if it cannot perform a completion activity immediately.


[[nesting-lras]]
==== Nesting LRAs

An activity can be scoped within an existing LRA using the `@LRA.Type.NESTED`
annotation element value. Invoking a method marked with this annotation
will start a new LRA whose behaviour is as follows:

1. A nested LRA can close or cancel independently of its parent.
2. A nested LRA which has closed must retain the ability to cancel the
   effects if the the parent cancels. This requirement must be enforced
   by participants.
3. If a nested LRA cancels then all of its children must cancel (even if
   they closed - see 2).
4. If a nested LRA closes then it, and all of its children, must close
   (but retain the ability to later compensate - see 2).

The javadoc for the <<source-LRA,LRA annotation>> discusses this element
in much more detail (look for the javadoc for the `NESTED` enum value
of the LRA.Type element).

In the following example the bookFlight method supports the presence of
an LRA context and if there is one present then it books a flight inside a
nested LRA which means that it can be cancelled independently of the parent
LRA. But if there is no LRA present then a new top level LRA is started
for the duration of the bookFlight method.

[source,java]
----
    @Inject
    private FlightService service;

    @LRA(LRA.Type.NESTED)
    @POST
    @Produces(MediaType.APPLICATION_JSON)
    public Booking bookFlight(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) String lraId,
                              @QueryParam("flightNumber") String flightNumber) {
        return service.book(lraId, flightNumber);
    }
----

Note that the mechanics of cancelling nested and top level LRAs is the same.

[[timing-out-lras-and-compensators]]
==== Timing out LRAs and Participants

The business logic may wish to control how long an LRA should remain active
for before it becomes eligible for automatic cancellation by providing values
for the `timeLimit` and `timeUnit` element of the `@LRA` annotation. For
example, to indicate that an LRA should automatically cancel after 100 milliseconds:

[source,java]
----
  @LRA(value = LRA.Type.REQUIRED, timeLimit = 100, timeUnit = ChronoUnit.MILLIS)
  @Path("/doitASAP")
  @GET
  @Produces(MediaType.APPLICATION_JSON)
  public Response theClockIsTicking(
      @HeaderParam(LRA.LRA_HTTP_CONTEXT_HEADER) String lraId) {...}
----

Furthermore, the ability to compensate or complete may be transient capabilities of a
service so participants can also be timed out. When the time limit is reached
the LRA is cancelled and participants will be notified via their compensation
(i.e. the method annotated with `@Compensate`). To set such a time limit add the
`timeLimit` and `timeUnit` element to the `@Compensate` and `@Complete`
annotations. If different time limits are set on these two methods then the
earliest of the two will take effect. An example of how a participant could
indicate that its' ability to compensate is limited to 100 milliseconds could be:

[source,java]
----
    @Compensate(timeLimit = 100, timeUnit = ChronoUnit.MILLIS)
    @Path("/compensate")
    @PUT
    public Response completeWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) String lraId,
                                 String userData) { ... }
----

In this example after 100 milliseconds has passed the implementation SHOULD
automatically cancel the LRA which will result in this method being invoked.

[[leaving-an-lra]]
==== Leaving an LRA

If a resource method annotated with @Leave is invoked in the context of an
LRA and if the bean class has registered a participant with the active LRA
it will be removed from the LRA just before the bean method is entered
(and will not be asked to complete or compensate when the LRA is
subsequently ended). Even though the method runs without an LRA context
the implementation MUST still make the context available via a JAX-RS header.

The javadoc for the <<source-Leave,Leave annotation>> provides greater detail
about this annotation. 

An example of this annotation is shown next:

[source,java]
----
    @Leave
    @Path("/leave")
    @PUT
    public Response leaveWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) String lraId) {
      // clean up since this participant is no longer associated with the LRA
    }
----

[[reporting-the-status-of-a-participant]]
==== Reporting the status of a participant

This specification supports distributed communications amongst services and
due to the unreliable nature of networks messages/requests can be lost, delayed,
duplicated etc and the implementation component responsible for invoking
participant completion/compensation logic may loose track of the status of
a participant. In this case, ideally it would just resend the
completion or compensation notification but if the participant does not
support idempotency then it MUST be able to report its status by
annotating one of the methods with the `@Status` annotation which should
report the status according to the
<<participant-state-model,participant state model>> by returning one of the
<<source-ParticipantStatus,ParticipantStatus enum values>>
(https://github.com/eclipse/microprofile-lra/blob/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/ParticipantStatus.java[github link]).

If the participant has already responded successfully to an `@Compensate`
or `@Complete` method invocation then it MAY report `404 Not Found`
HTTP status code or in the case of non-JAX-RS method returning 
<<source-ParticipantStatus,ParticipantStatus>> `null`. 
This enables the participant to free up resources.

[[forgetting-an-lra]]
==== Forgetting an LRA

If a participant is unable to complete or compensate immediately
(i.e. it has indicated that the request has been accepted and is
in progress) or because of a failure (i.e. will never be able to finish)
then it must remember the fact (by reporting its' status via the
`@Status` method) until explicitly told that it can clean up
using this `@Forget` annotation.

This requirement ensures that the implementation will be able to guarantee
the expectations of the LRA protocol under various failure conditions.
Only when the implementation is certain that participant has finished
will it tell it that it is okay to release any resources it associated
with the LRA.

[[reactive-support]]
==== Reactive Support

Implementations are expected to operate correctly when services use the
asynchronous and reactive features provided by JAX-RS. In particular the
implementation has no control over which thread the service logic uses
to do its work, therefore asynchronous operations may complete on any of:

- the caller thread;
- a managed thread;
- an unmanaged thread.

Furthermore, both the service writer and implementation should be
aware that the actual thread used to perform the operation may be used
by several requests running concurrently.

It has already been noted that
<<async-compensators,participant completion and compensation callbacks>>
can execute asynchronously but the same must also be true for the business
methods that execute in the context of an LRA. It is the responsibility
of the implementation to ensure that JAX-RS asynchronous features
continue to behave in the presence of these LRAs. The following
example shows a resource invocation that runs in the context of a
long running action and uses a Java 8 completion stage to return
an asynchronous response:

[source,java]
----
    @LRA(value = LRA.Type.REQUIRED,  // the method must run with an LRA
            end = true, // the LRA must end when the method completes
            cancelOnFamily = Response.Status.Family.SERVER_ERROR, // cancel LRA on any 5xx code
            cancelOn = NOT_FOUND) // cancel LRA on 404
    @Path("async-path")
    @POST
    public CompletionStage<Response> asyncInvocationWithLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) String lraId) {
        return CompletableFuture.supplyAsync(
                () -> {
                    try {
                        // a long running operation with lraId
                        ...
                        return Response.ok().entity(lraId).build();
                    } catch (BusinessException ex) {
                        return Response.status(NOT_FOUND).entity(lraId).build();
                    }
                },
                getExcecutorService()
        );
    }
----

With completion stages it is also possible to complete exceptionally. The
following example should run business logic asynchronously in the context
of an LRA but the LRA should be cancelled: forcing any registered
participant compensation handlers to run:

[source,java]
----
    @LRA(value = LRA.Type.REQUIRED, // the method must run with an LRA
         end = true, // the LRA must end when the method completes
         cancelOn = {Response.Status.NOT_FOUND}) // cancel on a 404 code
    @Path("completion-stage-exceptionally-lra")
    @POST
    public CompletionStage<Response> asyncInvocationWithException(
        @HeaderParam(LRA_HTTP_CONTEXT_HEADER) String lraId) {

        final CompletableFuture<Response> response = new CompletableFuture<>();

        excecutorService.submit(() -> {
            // excecute long running business activity finishing with a NOT_FOUND error
            // which causes the LRA to cancel
            response.completeExceptionally(
                    new WebApplicationException(
                        Response.status(Response.Status.NOT_FOUND).entity(lraId).build()));
        });

        return response;
    }
----

In addition to the use of completion stages, a resource method may also produce
asynchronous responses by injecting a JAX-RS `AsyncResponse` parameter using
the JAX-RS `@Suspended` annotation:

[source,java]
----
    @LRA(value = LRA.Type.REQUIRED, // the method must run with an LRA
         end = true) // the LRA must end when the method completes
    @Path("asyncresponse-lra")
    @POST
    public void asyncResponseLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) String lraId,
                         final @Suspended AsyncResponse ar) {
        excecutorService.submit(() -> {
            // excecute long running business activity and resume when done
            ar.resume(Response.ok().entity(lraId).build());
        });
    }
----

The previous use cases required a Java executor service, but it is also
possible to use other asynchronous API's. The next snippet shows
an LRA consuming an async API using an AWS S3 client:

[source,xml]
----
    <dependency>
        <groupId>software.amazon.awssdk</groupId>
        <artifactId>s3</artifactId>
        <version>2.0.0-preview-5</version>
    </dependency>
----

[source,java]
----
    S3AsyncClient client = S3AsyncClient.create();

    @LRA(value = LRA.Type.REQUIRED, end = true)
    @Path("completion-stage-lra")
    @POST
    public CompletionStage<PutObjectResponse> asyncInvocationWithLRA(
            @HeaderParam(LRA_HTTP_CONTEXT_HEADER) String lraId) {

        return client.putObject(
                PutObjectRequest.builder()
                        .bucket("aws-bucket")
                        .key("keyfile.in")
                        .build(),
                AsyncRequestProvider.fromFile(Paths.get("myfile.in"))
        ).whenComplete((r, e) -> {
            if (e == null) {
                Response.ok().entity(lraId).build();
            } else {
                Response.status(INTERNAL_SERVER_ERROR).entity(lraId).build());
            }
        });
    }

----

And finally, here is an example of how to run a non JAX-RS compensation asynchronously:

[source,java]
----
    @Compensate
    public CompletionStage<ParticipantStatus> compensate(final URI lraId) {
        // the compensation includes two long running operations:
        CompletableFuture<Void> memUpdate = CompletableFuture.runAsync((() -> {/* ... */}));
        CompletableFuture<Void> dbUpdate = CompletableFuture.runAsync((() -> {/* ... */}));

        CompletableFuture<Boolean> stage1 = memUpdate.handle((s, e) -> e == null);
        CompletableFuture<Boolean> stage2 = dbUpdate.handle((s, e) -> e == null);

        return stage1.thenCombine(stage2, (b1, b2) -> {
            if (b1 && b2) {
                // the memory and db updates finished successfully so report success
                return Compensated;
            }

            // otherwise report that there was a compensation failure
            return FailedToCompensate;
        });
    }
----

[[failure-resilience]]
==== Recovery Requirements

This LRA specification provides guarantees of Atomicity, Consistency and Durability
of work which places responsibilities on both spec implementers and application
writers. Failure points include loss of contact with components managing the
life cycle of LRAs and of participants. Application writers need to know
how to associate work with an LRA context so that the correct work
can be compensated for even after JVM or node crashes.
Likewise infrastructure components may become unavailable and state must
survive system failures. The specification is not prescriptive about how
an implementation achieves resiliency provided that it obeys the requirements
of the specification as laid out in this document.

[[appendix-1]]
== Appendix 1: Selected Javadoc API Descriptions

=== LRA Annotation
[[source-LRA]]
----
include::{sourcedir}/org/eclipse/microprofile/lra/annotation/ws/rs/LRA.java[LRA]
----
<<<

=== Leave Annotation
[[source-Leave]]
----
include::{sourcedir}/org/eclipse/microprofile/lra/annotation/ws/rs/Leave.java[Leave]
----
<<<

=== Compensate Annotation
[[source-Compensate]]
----
include::{sourcedir}/org/eclipse/microprofile/lra/annotation/Compensate.java[Compensate]
----
<<<

=== Complete Annotation
[[source-Complete]]
----
include::{sourcedir}/org/eclipse/microprofile/lra/annotation/Complete.java[Leave]
----
<<<

=== ParticipantStatus
[[source-ParticipantStatus]]
----
include::{sourcedir}/org/eclipse/microprofile/lra/annotation/ParticipantStatus.java/[ParticipantStatus]
----
<<<
