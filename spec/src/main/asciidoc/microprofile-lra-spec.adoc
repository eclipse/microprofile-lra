//   Copyright (c) 2018 Contributors to the Eclipse Foundation
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

:revnumber: 0.1
:revdate: 2018-03-27
:revremark: Specification
:version-label!:
:sectanchors:
:doctype: book
:license: Apache License v2.0
:source-highlighter: coderay
:toc: left
:toclevels: 4
:sectnums:
ifdef::backend-pdf[]
:pagenums:
endif::[]
:icons: font
:sourcedir: ../../../../api/src/main/java


[[long-running-actions]]
= Eclipse MicroProfile LRA

include::license-alv2.asciidoc[]

[[introduction]]
== Introduction

The proposal introduces annotations and APIs for services to coordinate
long running activities whilst still maintaining loose coupling and
doing so in such a way as to guarantee a globally consistent outcome
without the need to take locks on data.

[[motivation]]
== Motivation

In a loosely coupled service based environment there is sometimes a need
for different services to provide consistency guarantees. Typical
examples include:

* order processing involving three services (take order, bill customer,
ship product). If the shipping service finds that it is out of stock
then the customer will have been billed with no prospect of receiving
his item.
* an airline overbooks a flight which means that the booking count and
the flight capacity are inconsistent.

There are various ways that systems overcome such inconsistency but it
would be advantageous to provide a generic solution which handles
failure conditions, maintains state for those flows that span long
periods of time and ensures that remedial activities are called
correctly.

Traditional techniques for guaranteeing consistency in distributed
environments has focused on XA transactions where locks may be held for
long periods thereby introducing strong coupling between services and
decreasing concurrency to unacceptable levels. Additionally, if such a
transaction aborts then valuable work which may be valid will be rolled
back. In view of these issues an alternative approach is desirable.

Goals

* support long running actions
* no strong coupling between services
* allow actions to finish early
* allow some parts of a computation to be cancelled without
  affecting other parts of the computation (aka nested activities)
* guarantee execution of compensating actions if a business activity
  is cancelled

[[proposed-solution]]
== The solution

We propose a compensation based approach in which participants make
changes visible but register a compensatory action which is performed if
something goes wrong. We call the model LRA (short for Long Running
Action) and is based on work done within the
https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=ws-caf[OASIS
Web Services Composite Application Framework Technical Committee],
namely
https://www.oasis-open.org/committees/document.php?document_id=12794[Long
Running Action transaction model], but updated to be more suited for use
in microservice based architectures.

In the LRA model, an activity reflects business interactions: all work
performed within the scope of an activity is required to be
compensatable and the protocol ensures that when the activity terminates
then either all work will be accepted or will be compensated, i.e.
the activity’s work is either performed successfully or undone. For
example, when a user reserves a seat on a flight, the airline
reservation centre may take an optimistic approach and actually book the
seat and debit the user's account, relying on the fact that most of
their customers who reserve seats later book them; the compensation
action for this activity would be to un-book the seat and credit the
user’s account. How services perform their work and ensure it
can be undone if compensation is required are implementation choices and
is not exposed to the LRA model which simply defines the triggers for
compensation actions and the conditions under which those triggers are
executed. In other words, the LRA protocol is concerned only with
ensuring participants obey the protocol necessary to make an activity
compensatable and is intended to better model interactions between
microservices. Issues such as isolation of services between
potentially conflicting activities and durability of service work are
assumed to be implementation decisions. Although this may result in
non-atomic behaviour for the
overall business activity, other activities may be started by the
service to attempt to compensate in some other manner.

[[the-model]]
=== The Model

The model concerns participants (aka compensators), a logical coordinator
and a client. A client starts a new LRA via an annotation which results
in the creation of a new LRA.
When a business service does work that may have to be later compensated
it enlists a participant with the LRA which, when the client later closes
or cancels the LRA, operates on behalf of the service to undo the work
the service performed within the scope of an LRA or to compensate for the
fact that the original work could not be completed. The following diagram
shows the sequence of events that this model implies:

:imagesdir: images
.LRA Protocol Sequence
image::lra.png[align="center"]

The participants will be invoked in the following way when the LRA terminates:

* *Success*: the client has closed the LRA and the activity has completed
successfully. All participants (including ones enlisted with any LRAs nested
under the top level LRA) that are associated with the LRA
are informed that the activity has terminated and they can perform any
necessary cleanup.
* *Fail*: the client has cancelled the LRA and the activity has completed
unsuccessfully. All participants
that are registered with the LRA will be invoked to perform compensation
in the reverse order
footnote:[Note that calling participants in reverse order does not guarantee that
          the compensation actions will be performed in strict sequential order
          since participants are allowed to indicate that the compensation is in
          progress and will complete at some future time. Furthermore a
          participant can indicate that it failed to compensate, or could be
          unavailable in which case it will be periodically retried (out of
          order).].
The LRA forgets about all participants
that indicated they operated correctly. Otherwise, compensation may be
attempted again (possibly after a period of time) or alternatively a
compensation violation has occurred and must be logged. Each service is
required to log sufficient information in order to ensure (with best
effort) that compensation is possible even in the event of failures.
Note that compensation violations include the case where a participant
completes when asked to compensate.

Similar remarks apply to completion violations.

Interposition (nesting) and reliably storing the state of participants
allows the system to drive a consistent view of the outcome and to take
recovery actions in the event of failure, but allowing
always the possibility that recovery isn’t possible which must be logged
or flagged for the administrator and manual intervention may be necessary
to restore an application’s consistency.

A LRA and a participant both follow similar state models (with slightly
different wording to indicate that the states refer to the LRA as a whole
rather than to individual participants):

* `Active`: the LRA exists and has not been asked to close or cancel yet
* `Cancelling`: the LRA is currently being cancelled
* `Cancelled`: the LRA has successfully cancelled
* `FailedToCancel`: at least one participant was not able to
compensate
* `Closing`: the LRA is currently being closed
* `Closed`: the LRA has closed
* `FailedToClose`: at least one participant was not able to complete

Note that the model also allows parties to be reliably notified when
<<after-lra,LRAs reach one of the final states>>. Such parties are
referred to as LRA listeners (in contrast to participants).

:imagesdir: images
[[lra-state-model]]
.LRA State Model
image::lra-state-model.png[align="center" link="lra-state-model"]

And the participants state model has the following states:

* `Active`: the participant exists and has not been asked to compensate
or complete yet
* `Compensating`: a participant is currently compensating for the work
that it performed during the LRA.
* `Compensated`: a participant has successfully compensated for the work
that it performed during the LRA.
* `FailedToCompensate`: the participant was not able to compensate for the
work it did during the LRA.
* `Completing`: the participant is tidying up after being told to
complete.
* `Completed`: the participant has confirmed that it has finished
tidying up.
* `FailedToComplete`: the participant was unable to tidy-up some resources
it allocated during the LRA.

When a participant joins an LRA it is said to be enlisted and enters the state
model in the `Active` state.

:imagesdir: images
[[participant-state-model]]
.Participant State Model
image::participant-state-model.png[align="center" link="participant-state-model"]

Note that when the LRA has been asked to cancel it enters the state `Cancelling`
and will eventually ask all registered participants to enter the state
`Compensating`. A similar remark applies to the LRA state `Closing` and participant state
`Completing`.

The participant can be enlisted only once per LRA instance. When participant
is about to be enlisted multiple times (e.g. client calls the same `@LRA` method
several times) the follow-up enlistments of such participant MUST be ignored.

Different usage patterns for LRAs are possible, for example LRAs may be
used sequentially and/or concurrently, where the termination of one LRA
signals the start of some other unit of work within an application.
Additionally, speculative execution of work can be supported by nesting
LRAs, some of which can be cancelled independently of the parent LRA
whilst others are closed based on the outcome of other LRAs.
LRAs are units of compensatable work and an application may
have as many such units of work operating simultaneously as it needs to
accomplish its tasks. Furthermore, the outcome of work within LRAs may
determine how other LRAs are terminated. An application can be
structured so that LRAs are used to assemble units of compensatable work
and then held in the active state while the application performs other
work in the scope of different (concurrent or sequential) LRAs. Only
when the right subset of work (LRAs) is arrived at by the application
will that subset be confirmed; all other LRAs will be told to cancel
(complete in a failure state).

In the rest of this proposal we specify an API for
controlling the life cycle of and participation in LRAs:

[[java-annotations-for-lras]]
=== Java Annotations for LRAs

Support for the proposal in MicroProfile is primarily based upon the use
of Java annotations for controlling the life cycle of LRAs and of participants, i.e.
the service developer annotates JAX-RS resources to specify how
LRAs should be controlled and when to _enlist a class_ as a participant.

==== Quick overview of annotations

The definitive documentation for how the annotations affect the behaviour of a running
program is the javadoc and this specification should be read in conjunction with it.
The annotations are defined in the
https://github.com/eclipse/microprofile-lra/tree/master/api/src/main/java/org/eclipse/microprofile/lra/annotation[org.eclipse.microprofile.lra.annotation]
package:

[cols="1,4"]
|===
| Annotation | Description

| https://github.com/eclipse/microprofile-lra/tree/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/ws/rs/LRA.java#L40[@LRA]
  | Controls the life cycle of an LRA.
| https://github.com/eclipse/microprofile-lra/tree/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/Compensate.java#L29[@Compensate]
  | Indicates that the method should be invoked if the LRA is cancelled.
| https://github.com/eclipse/microprofile-lra/tree/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/Complete.java#L29[@Complete]
  | Indicates that the method should be invoked if the LRA is closed.
| https://github.com/eclipse/microprofile-lra/tree/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/Forget.java#L29[@Forget]
  | Indicates that the method may release any resources that were allocated for this LRA.
| https://github.com/eclipse/microprofile-lra/tree/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/Leave.java#L29[@Leave]
  | Indicates that this class is no longer interested in this LRA.
| https://github.com/eclipse/microprofile-lra/tree/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/Status.java#L30[@Status]
  | When the annotated method is invoked it should report the status.
|===

Briefly, these annotations are used as follows:

The application annotates some JAX-RS resource method with `@LRA` which determines whether the
method will run in the context of an LRA. Generally, if a method starts a new LRA it will
be closed when the method finishes execution (but elements of the annotation facilitate
full control over the LRA life cycle).

If execution is to run with an active LRA and the associated class contains other methods
annotated with `@Compensate` and `@Complete` then these methods will be associated with
the active LRA. They will be invoked when the LRA is subsequently cancelled or closed.
If the participant successfully compensates or completes then it may forget about the LRA.
Otherwise it should remember that it is still associated with the LRA and it MUST report
the status of the association using values in the
https://github.com/eclipse/microprofile-lra/tree/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/ParticipantStatus.java[`ParticipantStatus`]
enum according to the participant state model defined earlier.
It can report the status directly from the `@Compensate` or `@Complete` methods if they
are idempotent, otherwise it MUST provide a method annotated with `@Status`.

If the participant is no longer associated with the LRA (because it has successfully
compensated or completed or because it has left the LRA) it MAY return the
`410 Gone` HTTP status code from any of these methods.

If the participant knows it will never be able to compensate or complete then it MUST remember
that it could not until explicitly told that it can clean up by providing a method annotated with `@Forget`
(the requirement is marked MUST because message delivery is not guaranteed in a distributed system).

If multiple methods are annotated with the same annotation an arbitrary one will be chosen.

[[config-parameters]]
==== Configuration parameters

This specification has 1 configuration parameter which is retrieved using the MicroProfile Config principles.

     mp.lra.propagation.active=true

The allowed values for the configuration parameter are defined by the https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/converters.asciidoc[MicroProfile Config converter for boolean]:
`values for true (case insensitive) "true", "1", "YES", "Y" "ON". Any other value will be interpreted as false.

When a JAX-RS endpoint, or the containing class, is not annotated with @LRA, but it is called on a MicroProfile LRA compliant runtime,
the system will propagate the LRA related HTTP headers when this parameter resolves to true. The behaviour is similar to the
LRA.Type SUPPORTS (when true) and NOT_SUPPORTED (when false) values but only defines the propagation aspect.
In other words the class does not have to be a participant in order for the LRA context to propagate, i.e. such propagation of
the header does not imply that the LRA is in any particular state, and in fact the LRA may not even correspond to a valid LRA.

Also, there is no validation performed in any form of the LRA related HTTP headers. They are just propagated on an outgoing
request in the case the configuration value resolves to `true`. All values for the headers defined in `org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_CONTEXT_HEADER`
and `org.eclipse.microprofile.lra.annotation.ws.rs.LRA.LRA_HTTP_PARENT_CONTEXT_HEADER` needs to be propagated.

Because of this last statement an implementation does not need to guard against "spoofing of LRA ids":
security is specifically not defined in the specification and it is up to implementers to define the security elements of their approach.

[[lra-context]]
==== The LRA Context

When a method is invoked in the context of an LRA its identifier (of type java.net.URI) MUST be made
available to the business logic. This LRA is referred to as the `active context`.

For JAX-RS resource methods, the identifier is made available via request and
response headers which the business method can obtain using standard JAX-RS mechanisms,
i.e. `@Context` or by injecting a JAX-RS header param with the name specified by
the Java constant `LRA_HTTP_CONTEXT_HEADER` as defined <<source-LRA, in the LRA annotation class>>.
This header is referred to as the `context header`.

When using non-JAX-RS based 'complete' and 'compensate' methods (see <<non-jaxrs-participant-methods>>)
this identifier is passed as a method parameter.

The implementation MUST propagate the `active context` on outgoing JAX-RS
requests.

If an LRA is propagated to a resource that is not annotated with `@LRA` then the implementation looks at the
configuration parameter `mp.lra.propagation.active` to decide if the LRA context information in the header must
be propagated with the outgoing requests (value evaluates to `true`, the default) or not (value evaluates to `false`).

The user is allowed to manually assign the `context header` on JAX-RS requests
and responses:

===== Setting the context on outgoing JAX-RS requests

If the context is set on an outgoing JAX-RS request then it becomes the `active
context` for that invocation. When the invocation returns the context that
was active before the invocation once again becomes the active context.

===== Setting the context on JAX-RS responses

A resource is allowed to manually set the `context header` on JAX-RS responses.
Users should be careful when using this capability since this context will
overwrite whatever the implementation has set.

[[java-annotations]]
==== Starting and Ending LRAs

[[controlling-the-life-cycle-of-an-lra]]
The life cycle of an LRA is controlled via the <<source-LRA,LRA annotation>>
(https://github.com/eclipse/microprofile-lra/tree/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/ws/rs/LRA.java#L40[@LRA]).

The annotation MUST be applied to JAX-RS annotated methods, classes, superclasses or interface methods otherwise
it has no effect. It determines whether or not the JAX-RS method
will run in the context of an LRA and controls whether or not:

- any incoming context should be suspended and if so if a new one should be started.
- to start a new LRA.
- to end any LRA context when the method ends.
- to throw an exception if there should be an LRA present on method entry.
- to throw an exception if the method returns particular HTTP status codes.
- to enlist the class as a participant of the LRA.

When the @LRA annotation is defined multiple times, this is the order of precedence

- On the JAX-RS method itself.
- On the class declaration containing the JAX-RS method.
- On the method declaration of a superclass.
- On the method declaration of an interface.

More specifically, when the JAX-RS method and the class containing the JAX-RS method both have the
`@LRA` annotation, the one from the JAX-RS method should be used.

If the method is to run in the context of an LRA then the annotated class
MUST also contain a method annotated with one or both of `@Compensate` and `@AfterLRA`.
If the `@Compensate` annotation is present then the class
(aka participant or compensator) will be enlisted with the LRA.
If the `@AfterLRA` annotation is present then the class will be notified
when the LRA reaches one of <<lra-state-model,the final LRA states>>.
In the case that the class contains a `@Compensate` annotated method, this means that before
executing the `@LRA` annotated method, the implementation must be able to guarantee that the
participant has been or will eventually be registered with the LRA.
This implies that the LRA is effectively validated as being active since it is not possible
to enlist with an inactive LRA. There is an exception to this statement if the LRA is nested
and in the `Closed` state (since the transition `Closed` -> `Cancelling` is permitted). In this
case the method invocation will be allowed to proceed provided that the participant is already
registered with the LRA (please refer to the <<source-LRA,javadoc>> for the `NESTED`
value of the `LRA#value()`
element for more information about this situation, in particular if the method invocation
causes the LRA to close then the `@Complete` annotated method, if present, *is not* called
again). And if the participant is not registered with the LRA then the caller of the LRA
method will receive a `412` status response as described in the javadoc.

In the case that the class contains a `@AfterLRA` annotated method, this means that before
executing the `@LRA` annotated method, the implementation must be able to guarantee that the
listener will be notified about the outcome of the LRA.
The practical consequence of these requirements is that the implementation must durably record
that the participant/listener is associated with the LRA before allowing the business invocation
to proceed.

Enlisting with an LRA means that the instance will be notified when the current LRA is
subsequently cancelled or closed (if the class also contains a method
annotated with `@Complete`). In addition the implementation MUST generate a
URI for this participant and make it available to the business method (on which
the LRA annotation is defined) via a JAX-RS
header param with name defined by the Java constant `LRA_HTTP_RECOVERY_HEADER` as defined
<<source-LRA, in the LRA annotation>>
(https://github.com/eclipse/microprofile-lra/tree/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/ws/rs/LRA.java[github link]).
The header MUST also be made available to the application whenever any
of the participant callbacks are invoked. The application is free to ignore
this header.
Enlisting in an LRA is explained in more detail
<<compensating-activities,in a later section>> of this document.

It is the `LRA.Type` element of the LRA annotation that provides fine grained control over the
LRA for the duration of the execution of the annotated method and the reader
should consult the javadoc for details.

Bear in mind that the LRA annotation is expected to be used with JAX-RS
which expects the `Response` being the method return type.
If a `200 OK` response is to be returned then the method can
return any data type that it desires.
The specification does not discuss what happens when
an uncaught exception is thrown from the `@LRA` annotated method.
It's up to the framework to transform the thrown exception
to the JAX-RS `Response` error status code.
It's a usual practice the `RuntimeException` to be transformed
to the `5xx` `Response` status code.

The LRA annotation can be used to control whether or not the LRA context should
be closed when the method finishes (see the javadoc for the `LRA#end()`
element for details.

The LRA annotation can be used to control whether or not the LRA context should
be cancelled when the method finishes (see the javadoc for the `LRA#cancelOn()`
and `cancelOnFamily` elements for details).

When an LRA is present its identifier MUST be made available to
the business logic via request and response headers as described earlier
(using a header name specified in the Java constant `LRA_HTTP_CONTEXT_HEADER`).

The following is a simple example of how to start an LRA and how to receive
a notification when the LRA is later cancelled (`@Compensate` is invoked)
or closed (`@Complete` is invoked):

[source,java]
----
@Path("/")
@ApplicationScoped
public class SimpleLRAParticipant
{
    @LRA(LRA.Type.REQUIRES_NEW)
    @Path("/cdi")
    @PUT
    public void doInTransaction(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)
    {
        /*
         * Perform business actions in the context of the LRA identified by the
         * value in the injected JAX-RS header. This LRA was started just before
         * the method was entered (REQUIRES_NEW) and will be closed when the
         * method finishes at which point the completeWork method below will be
         * invoked.
         */
    }

    @Complete
    @Path("/complete")
    @PUT
    public Response completeWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId,
                                 String userData)
    {
        /*
         * Free up resources allocated in the context of the LRA identified by the
         * value in the injected JAX-RS header.
         *
         * Since there is no @Status method in this class, completeWork MUST be
         * idempotent and MUST return the status.
         */
         return Response.ok(ParticipantStatus.Completed.name()).build();
    }

    @Compensate
    @Path("/compensate")
    @PUT
    public Response compensateWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId,
                                   String userData)
    {
        /*
         * The LRA identified by the value in the injected JAX-RS header was
         * cancelled so the business logic should compensate for any actions
         * that have been performed while running in its context.
         *
         * Since there is no @Status method in this class, compensateWork MUST be
         * idempotent and MUST return the status
         */
         return Response.ok(ParticipantStatus.Compensated.name()).build();
    }
}
----

The example also shows that when an LRA is present its identifier can be obtained
by reading the request headers.

The next example demonstrates how to start an LRA in one method and close
it in a different method using the `LRA#end` element.
It also shows how to configure the LRA to be automatically cancelled if the business method
returns the particular HTTP status codes identified in the `cancelOn` and
`cancelOnFamily` elements:

[source,java]
----
  @LRA(value = LRA.Type.REQUIRED, // if there is no incoming context a new one is created
       cancelOn = {
           Response.Status.INTERNAL_SERVER_ERROR // cancel on a 500 code
       },
       cancelOnFamily = {
           Response.Status.Family.CLIENT_ERROR // cancel on any 4xx code
       },
       end = false) // the LRA will continue to run when the method finishes
  @Path("/book")
  @POST
  public Response bookTrip(...) { ... }

  @LRA(LRA.Type.MANDATORY, // requires an active context before method can be executed
       end = true) // end the LRA started by the bookTrip method
  @Path("/confirm")
  @PUT
  public Booking confirmTrip(Booking booking) throws BookingException { ... }
----

The `end = false` element on the bookTrip method forces the LRA to continue running when
the method finishes and the `end = true` element on the confirmTrip method forces the LRA
(started by the bookTrip method) to close the LRA.

[[after-lra]]
===== Discovering the Outcome of an LRA

As remarked in the previous section, a JAX-RS resource method runs with an active
context depending upon the value specified in the `@LRA` annotation.
The final state of this LRA can be discovered by marking one of the other methods
in the class with the `@AfterLRA` annotation. When the LRA enters a terminal state
the method will be passed the id of the LRA together with the `LRAStatus` (see the
javadoc for the `@AfterLRA` annotation for more information). Note that the final
states of an LRA is defined by <<lra-state-model,the LRA state model>> and it
would be a specification violation if the implementation calls the method when the
LRA is not in a final state. Further information about method signatures and
JAX-RS response codes is given below in section <<jaxrs-participant-methods>>.

Note that the resource does not need to be a participant in order to receive this
notification. Therefore in the following resource definition, although no method
is annotated with `@Compensate`, if the method called
`activityWithLRA` is invoked then the method `notifyLRAFinished` will be called
when the LRA finishes:

[source,java]
----
public class BusinessResource {
    @PUT
    @Path("/work")
    @LRA(value = LRA.Type.REQUIRES_NEW)
    public Response activityWithLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {
        // perform a business action in the context of lraId
        return Response.ok().build();
    }

    @PUT
    @Path("/after")
    @AfterLRA // method is called when the LRA associated with the method activityWithLRA finishes
    public Response notifyLRAFinished(@HeaderParam(LRA_HTTP_ENDED_CONTEXT_HEADER) URI lraId,
                                      LRAStatus status) {

        switch (status) {
            case Closed:
                // the LRA was successfully closed
            ...   
        }
    }
}
----

[[compensating-activities]]
==== Compensating Activities

As remarked elsewhere, the LRA specification attempts to enforce some of the traditional
guarantees provided by transactional systems such as atomicity (all or nothing)
whilst relaxing others, such as isolation of work amongst participants. The characteristic
of strong consistency of data (the system can only be observed to transition between
consistent states) is also relaxed in favour of what is referred to as `eventual
consistency`. The LRA specification ensures atomicity and eventual consistency by
placing certain requirements on the entities that participate in the protocol
which we now discuss (further details of these responsibilities can be found in
the javadoc for the participant annotations).

The application developer indicates which method to use for a compensating
activity by marking it with the `@Compensate` annotation.
Whenever the associated resource is invoked in the context of
an LRA the method corresponding to this `@Compensate` method MUST be enlisted with
the LRA: enlistment means that if the LRA is subsequently cancelled then the compensation
method MUST be invoked.

The specification does not mandate when this method is invoked
but it does guarantee that it will eventually be called (this is the precise
meaning of the term `eventual consistency` as used in this specification).
Under failure conditions the system will keep retrying until it is certain that the
participant has been successfully notified.

The LRA model is quite flexible in how business methods perform compensations.
If a compensating activity is brief then the synchronous model may be appropriate:

[source,java]
----
    @Compensate
    @Path("/compensate")
    @PUT
    public Response compensatePreviousAction(
            @HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {
        getActivity(lraId).setCompensated();  // business logic for handling the LRA, not provided by spec or implementation.

        return Response.ok();
    }
----

On the other hand, the compensating logic may involve concerted activities,
perhaps even compensating in the context of another LRA. In this case the
protocol accommodates a more decoupled mode of operation - the following example
shows how a compensating activity can be started in the background:

[source,java]
----
    @Compensate
    @Path("/compensate")
    @PUT
    public Response compensatePreviousAction(
            @HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {

        // business logic for handling the LRA, not provided by spec or implementation.
        ActivityClient client = getActivity(lraId).getResourceForCompensation();
        String backgroundActivity = client.compensate(lraId);
        ...
        return Response.accepted().build();
    }
----

Here the business logic reports that the compensation is in progress by returning
the `202 Accepted` HTTP status code. Of course the system must still guarantee
atomic outcomes so the participant is responsible for reporting when it has
finished compensating: it may do this by allowing the compensation method
to be called multiple times in the context of the same LRA until the final state
is known. But if the method `compensatePreviousAction` should not be called a
second time (i.e. it is not idempotent) then the participant has the option of
reporting its` progress using the `@Status` annotation:

[source,java]
----
    @Status
    @Path("/status")
    @GET
    public Response status(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {
        if (isFinished(lraId))  // Business logic, not provided by spec or Implementation
            return Response.ok().entity(ParticipantStatus.Compensated).build();
        else
            return Response.ok().entity(ParticipantStatus.Compensating).build();
    }
----

Notice that in this code example the participant is reporting progress using
the appropriate `ParticipantStatus` enum according to the <<participant-state-model,the
participant state model>>.

But what if the business logic is unable to compensate for a previous action?
In this case the participant must remember that it was unable to compensate
by reporting `FailedToCompensate` either via the compensate method, for example

[source,java]
----
    @Compensate
    @Path("/compensate")
    @PUT
    public Response compensatePreviousAction(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {
        if (isFailed(lraId)) // Business logic, not provided by spec or Implementation
              return Response.ok().entity(ParticipantStatus.FailedToCompensate).build();
        ...
    }
----

or it can report the failure via the `@Status` method:

[source,java]
----
    @Status
    @Path("/status")
    @GET
    public Response status(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {
        if (isFailed(lraId)) // Business logic, not provided by spec or Implementation
            return Response.ok().entity(ParticipantStatus.FailedToCompensate).build();
        ...
    }
----

In the successful case the participant SHOULD clean up any resources it allocated in the
context of the LRA. Any requests (including the current one) made in the context of the
same LRA MAY return a `410 Gone` status code.

In the failure case the participant is responsible for remembering that it failed until
it is explicitly told that it can clean up via the `@Forget` method:

[source,java]
----
    @Forget
    @Path("/forget")
    @DELETE
    public Response forget(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {
        // Business logic, not provided by spec or Implementation
        if (isFailed(lraId)) {
            cleanupResources(lraId);
        }

        return Response.ok().build();
    }
----

The resource class MAY also contain a method marked with the `@Complete` annotation.
If such a method is present then the method MUST be invoked when the associated LRA
is closed. Again, the specification does not MANDATE when the method is called,
just that it will eventually be invoked. Typically the resource would use this call
to perform any clean up actions. The method is optional since such clean up actions
may not be necessary, for example consider a system that just tracks hotel reservations
and has operations for booking a room or cancelling the reservation (`@Compensate`).
Since this system is passive, once a room is booked, it does not make any difference
if the LRA is completed or not: the room will be unavailable for others. If it receives
a call to `@Compensate` then it will free the room. But it won't do anything on
`@Complete`.

If the participant successfully compensates or completes then it may forget about
the LRA. Otherwise it should remember that it is still associated with the LRA and
it MUST report the status of the association using the
<<jaxrs-response-table,appropriate JAX-RS response code>> if it uses JAX-RS for
participant notifications. If it does not use JAX-RS for participant notifications
then it MUST report the status of the association using one of the values in the
`ParticipantStatus` enum according to the <<participant-state-model,the
participant state model>>. If the compensation and completion methods are not
idempotent then there MUST be a method annotated with `@Status` which reports the
status. Otherwise the compensation and completion methods should return the status.
If the participant is no longer associated with the LRA (because it has successfully
compensated/completed) it MAY return the `410 Gone` HTTP status code from any
of these methods. If it knows it will never be able to compensate or complete then
it MUST remember the fact until explicitly told that it can clean up by providing
a method annotated with `@Forget` (the requirement is marked MUST because message
delivery is not guaranteed in a distributed system).

If there is no `@Status` then the `@Compensate` or `@Complete` methods will continue
to be invoked until the implementation knows it has the final status.

If the `@Compensate` or `@Complete` annotation is present on multiple methods
then an arbitrary one is chosen.

The javadoc for the <<source-Compensate,Compensate annotation>> provides
more details about this annotation.

Similarly, the javadoc for the <<source-Complete,Complete annotation>>
provides details about the `@Complete` annotation.

==== Participant marker annotations method signatures

The participant marker annotations are annotations that allow users to mark a method
for the execution by the LRA implementation according to the <<participant-state-model,
the participant state model>>. These annotations are:

* `@Compensate` -- a method to be executed when the LRA is cancelled
* `@Complete` -- a method to be executed when the LRA is closed
* `@Status` -- a method that allow user to state status of the participant with regards
to a particular LRA
* `@Forget` -- a method to be executed when the LRA allows participant to
clear all associated information

There is also a listener marker annotation:

* `@AfterLRA` -- a method that will be reliably invoked when the LRA enters one of
the final states

This specification differentiates two types of participant method definitions --
methods associated with the JAX-RS resource method or the methods which are not
bound to JAX-RS.

[[jaxrs-participant-methods]]
===== JAX-RS methods

The following table presents expectations that are placed on individual
annotations when associated with JAX-RS resource methods:

[[jaxrs-response-table]]
|===
| Annotation | Required HTTP method | Expected status codes | Response

| `@Compensate`
| PUT
| 200, 202, 410, 500
| <<source-Compensate,see javadoc>>

| `@Complete`
| PUT
| 200, 202, 410, 500
| <<source-Complete,see javadoc>>

| `@Status`
| GET
| 200, 202, 410
| <<source-ParticipantStatus,ParticipantStatus>>

| `@Forget`
| DELETE
| 200, 410
| no expectations

| `@AfterLRA`
| PUT
| 200
| no expectations

|===

Please refer to the javadoc for each annotation for the description of the
conditions under which the various JAX-RS response codes are returned.

Returning the status code 410, when appropriate - see the above table, has the same effect
as status 200. The participant indicates with this response that it is no longer aware of the
LRA identification but the implementation MUST assume that all required actions are performed
, which is equivalent with return status 200, and that the participant already forgot about it
(participant is allowed to forget about a LRA identification when completely handled)

If the method annotated with `@AfterLRA` returns an unexpected HTTP status
or never reaches the caller then the implementation MUST invoke the same method again.

If the annotated method returns an unexpected HTTP status code the implementation MAY
invoke the same method again with the following caveat: if there is no `@Status` method
and the implementation receives an unexpected response code from either of the
`@Compensate` or `@Complete` invocations then it MUST reinvoke the method. [Note that
this caveat applies to the situation where the response is lost since the caller will
not see the correct code].

Users are allowed to reuse existing JAX-RS endpoints for participant method definitions.
In this case the LRA implementation MUST ensure that invoking these methods outside of the
implementation of the LRA specification will not influence any running LRA.

Specifically, developers should NEVER call any JAX-RS endpoint for participant callback methods
(@Compensate, @Complete, @Status, @Forget, and @AfterLRA) where they
add a header defined by the Java constant `LRA_HTTP_RECOVERY_HEADER`.
This way, a developer can distinguish if the call is made by an end-user or the implementation and
make sure that it will not influence the participant of the LRA when called directly.

===== Non-JAX-RS afterLRA method

A method annotated with `@AfterLRA` that is not a JAX-RS resource method MUST accept
two arguments of type URI and LRAStatus, in that order. The first parameter holds
an LRA context and the second parameter holds the final status of the LRA. If the
signature does not conform to this requirement then the implementation MUST
prohibit the successful startup of the application (e.g. through the startup time
runtime exception).

An example of a valid signature is:

[source,java]
----
@AfterLRA
public void onLRAEnd(URI lraId, LRAStatus status)
----

[[non-jaxrs-participant-methods]]
===== Non-JAX-RS participant methods

When the participant annotations are applied to the non-JAX-RS resource methods they
MUST adhere to these predefined signatures:

* *Return type*:
** `void`: successful execution is mapped to `Compensated` or `Completed` participant statuses,
 error execution is handled by <<non-jax-rs-exceptions, exceptions>> thrown in the participant method
*** not applicable for `@Status` participant methods
** <<source-ParticipantStatus,ParticipantStatus>>
** `javax.ws.rs.core.Response`: handled similarly as for
<<jaxrs-participant-methods, JAX-RS participant methods>>
** `java.util.concurrent.CompletionStage`: with the parameter of any of the previously
defined types
* *Arguments*: up to 2 arguments of types in this order:
** `java.net.URI`: representing current LRA context identification
** `java.net.URI`: representing potential parent LRA context identification

Declaring more than two arguments, different types of arguments or different return type
for any non-JAX-RS method annotated with the participant marker annotation MUST result
in the prohibition of the successful application startup (e.g. through the startup
time runtime exception).

Please note that both arguments are optional but the order is required. This means that
if only one argument is provided this argument will contain the value of the current
active LRA context (not the parent LRA context in case of nested LRA).

Examples of valid signatures:

[source,java]
----
@Compensate
public void compensate(URI lraId, URI parentId)

@Complete
public Response complete(URI lraId)

@Status
public CompletionStage<ParticipantStatus> status(URI lraId)
----

Examples of invalid signatures:

[source,java]
----
@Compensate
public void compensate(String lraId, String parentId) // invalid types of arguments

@Compensate
public String compensate(URI lraId) // invalid return type

@Forget
public void forget(URI lraId, URI parentId, String additional) // too many arguments
----

[[non-jax-rs-exceptions]]
If any of the described methods throws an exception, we distinguish two cases depending
on the exception type:

* `WebApplicationException` -- the exception is mapped to the HTTP response it carries
and then handled as defined in the section
<<jaxrs-participant-methods, JAX-RS participant methods>>
* any other exception
** @Compensate and @Complete - results into `FailedToCompensate` or `FailedToComplete` 
participant states
** @Status and @Forget - as the participant may have already compensated (or completed)
or may in the process of compensation (completion) the exception in these methods should
result into failure condition (in JAX-RS this condition is represented by
500 return HTTP status code) which individual interpretation is left further unspecified.

In case the implementation of this specification exposes non-JAX-RS participant methods
to be able to call them externally (e.g. the HTTP proxy) then it MUST protect every
exposed method from unauthorized access. The specific security details are not specified.

[[eventual-compensations]]
==== Eventual compensations

[[async-compensators]]
If a resource cannot perform a compensation activity
immediately the `@Compensate` method MUST report that the activity
is still in progress using one of the following options:

- Return a `CompletionStage` or mark the method as asynchronous
  (using the `javax.ws.rs.container.Suspended` annotation). The future must
  report the final status when the stage completes (if it delivers an
  intermediate state then the implementation MUST use the `@Status` method if
  it exists, and if there is no such method it will reinvoke the `@Compensate`
  method). Please refer to the section
  <<reactive-support,about reactive support>> for more details.
- A JAX-RS method can return a `202 Accepted` HTTP status code.
  If there is no `@Status` method then the response MAY provide
  a status URL in the `HTTP Location` header field so that the
  implementation can discover the final outcome.
  This URL, if present, MUST obey the requirements specified in
  the javadoc for the <<source-Status,Status annotation>>.
  If the developer has not provided an `@Status` method nor a status
  URL then the implementation MUST reinvoke the `@Compensate` method
  (i.e. it MUST be idempotent).
- A non JAX-RS method can return `ParticipantStatus.Compensating`.

The `@Status` method, if present, MUST report the progress of the compensation.

Similarly if the resource cannot perform a completion activity immediately.

[[nesting-lras]]
==== Nesting LRAs

An activity can be scoped within an existing LRA using the `@LRA.Type.NESTED`
annotation element value. Invoking a method marked with this annotation
will start a new LRA whose behaviour is as follows:

1. A nested LRA can close or cancel independently of its parent.
2. A nested LRA which has closed must retain the ability to cancel the
   effects if the the parent cancels. This requirement must be enforced
   by participants. If the participant has a Forget method then it MUST
   be invoked if the parent LRA is closed. The Forget method is described
   in the section <<forgetting-an-lra,Forgetting an LRA>>.
3. If a nested LRA cancels then all of its children must cancel (even if
   they closed - see 2).
4. If a nested LRA closes then it, and all of its children, must close
   (but retain the ability to later compensate - see 2).

The javadoc for the <<source-LRA,LRA annotation>> discusses this element
in much more detail (look for the javadoc for the `NESTED` enum value
of the LRA.Type element).

In the following example the bookFlight method supports the presence of
an LRA context and if there is one present then it books a flight inside a
nested LRA which means that it can be cancelled independently of the parent
LRA. But if there is no LRA present then a new top level LRA is started
for the duration of the bookFlight method.

[source,java]
----
    @Inject
    private FlightService service;

    @LRA(LRA.Type.NESTED)
    @POST
    @Produces(MediaType.APPLICATION_JSON)
    public Booking bookFlight(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId,
                              @QueryParam("flightNumber") String flightNumber) {
        // business logic for handling the LRA, not provided by spec or implementation.
        return service.book(lraId, flightNumber);
    }
----

Note that the mechanics of cancelling nested and top level LRAs is the same.

[[timing-out-lras-and-compensators]]
==== Timing out LRAs

The business logic may wish to control how long an LRA should remain active
before it becomes eligible for automatic cancellation by providing values
for the `timeLimit` and `timeUnit` element of the `@LRA` annotation. For
example, to indicate that an LRA should automatically cancel after 100 milliseconds:

[source,java]
----
  @LRA(value = LRA.Type.REQUIRED, timeLimit = 100, timeUnit = ChronoUnit.MILLIS)
  @Path("/doitASAP")
  @GET
  @Produces(MediaType.APPLICATION_JSON)
  public Response theClockIsTicking(
      @HeaderParam(LRA.LRA_HTTP_CONTEXT_HEADER) URI lraId) {...}
----

Furthermore, the ability to compensate or complete may be transient capabilities of a service so participants can also be timed out.
When the timeout is reached, the LRA moves to the state `Cancelling` and all registered participants receive a `Compensate`
call. The same actions are performed then the case where the LRA is cancelled.

When a participant joins an existing transaction using the `@LRA(value = ...)` annotation, the timeout of
the already active Long Running Action can be influenced by the `timeLimit` and `timeUnit` defined on this annotation.
The implementation should calculate the moment in time the LRAs would become eligible for cancellation based on the time
the request enters the JAX-RS method and the timeout information found on the `@LRA`.  When this moment is earlier than
the moment calculated for the LRA at that time, this new moment becomes the time out moment for the LRA.
So when multiple participants define a timeout period, the earliest one will trigger the cancellation of the LRA.

Since the specification targets microservices running in different JVM's there are
potential issues around how timing constraints are handled:

A timeout is a duration which results in some calculated end time. If different systems
use different timezones or clock granularity then there is potential for different parts
of the system to have different views of the current time.  Therefore implementations
must be careful to avoid using absolute times and be aware that absolute synchronisation
between clocks is not possible, and therefore, where possible, rely on a duration instead.
If an absolute time is required then the recommendation is to use UTC which is a universal
time standard to which all timezones can be canonically converted. This will provide some
degree of alignment between clocks (where alignment means that clocks are only
approximately globally synchronised).

Potential reasons for requiring absolute time values, as opposed to durations, include:

1. When a failed server is restarted the implementation [of this specification] needs to
   calculate how long is left for timed LRAs to become eligible for cancellation based on
   on how much time elapsed before the server failed and how much time elapsed before the
   failed server was restarted. Such calculations can only be made if the absolute time of
   expiry of the LRA is known.
2. In a centralised coordinator based system, if another server takes control of the LRA
   then the absolute time would be required.
3. One could envisage a non centralised implementation that relies on absolute time values
   to determine when LRAs may be cancelled. In such an approach it is even more important
   that different clocks are aligned. Failure to align clocks in such a system would
   result in higher failure rates for LRAs.


If there are edge cases around timing of actions or if local clocks
cannot be relied upon then there are risks that different parts of the system may
perform conflicting actions. The implementation must strive to minimise these risks
but if they do occur then it MUST detect the conflict and force the LRA into
<<lra-state-model,one of the failure states>> and it MUST report the conflict
(the actual mechanism by which it does so is unspecified).

Also note that time limits are never absolute with respect to when LRAs are actually
cancelled: they are hints to the system that if the time limit is breached then
compensation may not be possible and an implementation should move the state of the
LRA to cancelling. It is also possible for an implementation to miss a deadline
(for whatever reason) and some other part of the system cancels the LRA before it
notices. In this scenario there would be a potential conflict since one of the
participants is no longer able to compensate. But as mentioned in the introduction to
this specification, failure states are permissible but "they must be logged or
flagged for the administrator and manual intervention may be necessary to restore
an application’s consistency".

[[leaving-an-lra]]
==== Leaving an LRA

If a resource method annotated with @Leave is invoked in the context of an
LRA and if the bean class has registered a participant with the active LRA
it will be removed from the LRA just before the bean method is entered
(and will not be asked to complete or compensate when the LRA is
subsequently ended). Even though the method runs without an LRA context
the implementation MUST still make the context available via a JAX-RS header.

The javadoc for the <<source-Leave,Leave annotation>> provides greater detail
about this annotation.

An example of this annotation is shown next:

[source,java]
----
    @Leave
    @Path("/leave")
    @PUT
    public Response leaveWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {
      // clean up since this participant is no longer associated with the LRA
    }
----

[[reporting-the-status-of-a-participant]]
==== Reporting the status of a participant

This specification supports distributed communications amongst services and
due to the unreliable nature of networks messages/requests can be lost, delayed,
duplicated etc and the implementation component responsible for invoking
participant completion/compensation logic may loose track of the status of
a participant. In this case, ideally it would just resend the
completion or compensation notification but if the participant does not
support idempotency then it MUST be able to report its status by
annotating one of the methods with the `@Status` annotation which should
report the status according to the
<<participant-state-model,participant state model>> by returning one of the
<<source-ParticipantStatus,ParticipantStatus enum values>>
(https://github.com/eclipse/microprofile-lra/blob/master/api/src/main/java/org/eclipse/microprofile/lra/annotation/ParticipantStatus.java[github link]).

If the participant has already responded successfully to an `@Compensate`
or `@Complete` method invocation then it MAY report `410 Gone`
HTTP status code or in the case of non-JAX-RS method returning
<<source-ParticipantStatus,ParticipantStatus>> `null`.

Let's provide some intuition on this matter with the following example.

Let's have an LRA participant containing methods annotated with `@Compensate` and `@Status`.
The LRA is cancelled and the LRA implementation tries to invoke the participant's `@Compensate` method.
At that time a network failure happens. The LRA implementation receives a network error as the result of the call.
Now it cannot be sure if the `@Compensate` call passed through and participant has already compensated the work
and only the response was lost or if the `@Compensate` call has not reached the participant at all.
As the participant defines the `@Status` method the LRA implementation MUST invoke it to find the participant's true status
(invocation can be processed several times until succeeds).
The participant's `@Status` method is expected to indicate whether the `@Compensate` was successfully processed.

* If the participant processed the `@Compensate` call it may <<jaxrs-participant-methods, has already forgotten about the LRA identification>>.
  Then for JAX-RS participant, the response is `410 Gone`. For non-JAX-RS participant, the method returns `null`.
  The implementation MUST assume that all required actions are performed and the implementation MUST NOT repeat the invocation.
* If the participant compensated successfully but it has not erased the notion of the LRA identity yet it may return
  <<source-ParticipantStatus,ParticipantStatus>> of `Compensated`. For JAX-RS participant it's a body of the response of return code `200`.
  For the non-JAX-RS participant case, consult the section <<non-jaxrs-participant-methods>> (one option is to provide `Compensated` as the method return value).
  The implementation MUST NOT repeat the invocation of the `@Compensate` method.
* If the `@Compensate` method was invoked initially but the compensation logic failed the participant status is `FailedToCompensate`.
  The LRA implementation then has to <<the-model,log sufficient information>> in such situation.
  For JAX-RS participant, the response is `2OO OK` with participant status sent in the response body.
  For non-JAX-RS participant case consult section <<non-jaxrs-participant-methods>> about return values.
  The implementation MUST NOT repeat the invocation of the `@Compensate` method.
* If the participant has not yet compensated (ie. the initial invocation of `@Compensate` did not go through)
  then the `ParticipantStatus` will indicate the participant status with `Active`.
  The implementation MUST repeat the invocation of the `@Compensate` method.


[[forgetting-an-lra]]
==== Forgetting an LRA

If a participant is unable to complete or compensate immediately
(i.e. it has indicated that the request has been accepted and is
in progress) or because of a failure (i.e. will never be able to finish)
then it must remember the fact (by reporting its' status via the
`@Status` method) until explicitly told that it can clean up
using this `@Forget` annotation.

This requirement ensures that the implementation will be able to guarantee
the expectations of the LRA protocol under various failure conditions.
Only when the implementation is certain that participant has finished
will it tell it that it is okay to release any resources it associated
with the LRA.

If a participant is enlisted in a nested LRA then it can ask to be notified
when the parent LRA closes using this `@Forget` annotation. This feature is
useful since a nested LRA can be closed independently from its parent but
it must retain the ability to compensate until the parent has finished.
Typically a participant would perform clean up actions in this method.

[[reactive-support]]
==== Reactive Support

Implementations are expected to operate correctly when services use the
asynchronous and reactive features provided by JAX-RS. In particular the
implementation has no control over which thread the service logic uses
to do its work, therefore asynchronous operations may complete on any of:

- the caller thread;
- a managed thread;
- an unmanaged thread.

Furthermore, both the service writer and implementation should be
aware that the actual thread used to perform the operation may be used
by several requests running concurrently.

It has already been noted that
<<async-compensators,participant completion and compensation callbacks>>
can execute asynchronously but the same must also be true for the business
methods that execute in the context of an LRA. It is the responsibility
of the implementation to ensure that JAX-RS asynchronous features
continue to behave in the presence of these LRAs. The following
example shows a resource invocation that runs in the context of a
long running action and uses a Java 8 completion stage to return
an asynchronous response:

[source,java]
----
    @LRA(value = LRA.Type.REQUIRED,  // the method must run with an LRA
            end = true, // the LRA must end when the method completes
            cancelOnFamily = Response.Status.Family.SERVER_ERROR, // cancel LRA on any 5xx code
            cancelOn = NOT_FOUND) // cancel LRA on 404
    @Path("async-path")
    @POST
    public CompletionStage<Response> asyncInvocationWithLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {
        return CompletableFuture.supplyAsync(
                () -> {
                    try {
                        // a long running operation with lraId
                        ...
                        return Response.ok().entity(lraId).build();
                    } catch (BusinessException ex) {
                        return Response.status(NOT_FOUND).entity(lraId).build();
                    }
                },
                getExcecutorService()
        );
    }
----

With completion stages it is also possible to complete exceptionally. The
following example should run business logic asynchronously in the context
of an LRA but the LRA should be cancelled: forcing any registered
participant compensation handlers to run:

[source,java]
----
    @LRA(value = LRA.Type.REQUIRED, // the method must run with an LRA
         end = true, // the LRA must end when the method completes
         cancelOn = {Response.Status.NOT_FOUND}) // cancel on a 404 code
    @Path("completion-stage-exceptionally-lra")
    @POST
    public CompletionStage<Response> asyncInvocationWithException(
        @HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {

        final CompletableFuture<Response> response = new CompletableFuture<>();

        executorService.submit(() -> {
            // execute long running business activity finishing with a NOT_FOUND error
            // which causes the LRA to cancel
            response.completeExceptionally(
                    new WebApplicationException(
                        Response.status(Response.Status.NOT_FOUND).entity(lraId).build()));
        });

        return response;
    }
----

In addition to the use of completion stages, a resource method may also produce
asynchronous responses by injecting a JAX-RS `AsyncResponse` parameter using
the JAX-RS `@Suspended` annotation:

[source,java]
----
    @LRA(value = LRA.Type.REQUIRED, // the method must run with an LRA
         end = true) // the LRA must end when the method completes
    @Path("asyncresponse-lra")
    @POST
    public void asyncResponseLRA(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId,
                         final @Suspended AsyncResponse ar) {
        executorService.submit(() -> {
            // execute long running business activity and resume when done
            ar.resume(Response.ok().entity(lraId).build());
        });
    }
----

The previous use cases required a Java executor service, but it is also
possible to use other asynchronous API's. The next snippet shows
an LRA consuming an async API using an AWS S3 client:

[source,xml]
----
    <dependency>
        <groupId>software.amazon.awssdk</groupId>
        <artifactId>s3</artifactId>
        <version>2.0.0-preview-5</version>
    </dependency>
----

[source,java]
----
    S3AsyncClient client = S3AsyncClient.create();

    @LRA(value = LRA.Type.REQUIRED, end = true)
    @Path("completion-stage-lra")
    @POST
    public CompletionStage<PutObjectResponse> asyncInvocationWithLRA(
            @HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {

        return client.putObject(
                PutObjectRequest.builder()
                        .bucket("aws-bucket")
                        .key("keyfile.in")
                        .build(),
                AsyncRequestProvider.fromFile(Paths.get("myfile.in"))
        ).whenComplete((r, e) -> {
            if (e == null) {
                Response.ok().entity(lraId).build();
            } else {
                Response.status(INTERNAL_SERVER_ERROR).entity(lraId).build());
            }
        });
    }

----

And finally, here is an example of how to run a non JAX-RS compensation asynchronously:

[source,java]
----
    @Compensate
    public CompletionStage<ParticipantStatus> compensate(final URI lraId) {
        // the compensation includes two long running operations:
        CompletableFuture<Void> memUpdate = CompletableFuture.runAsync((() -> {/* ... */}));
        CompletableFuture<Void> dbUpdate = CompletableFuture.runAsync((() -> {/* ... */}));

        CompletableFuture<Boolean> stage1 = memUpdate.handle((s, e) -> e == null);
        CompletableFuture<Boolean> stage2 = dbUpdate.handle((s, e) -> e == null);

        return stage1.thenCombine(stage2, (b1, b2) -> {
            if (b1 && b2) {
                // the memory and db updates finished successfully so report success
                return Compensated;
            }

            // otherwise report that there was a compensation failure
            return FailedToCompensate;
        });
    }
----

[[failure-resilience]]
==== Recovery Requirements

This LRA specification provides guarantees of Atomicity, Consistency and Durability
of work which places responsibilities on both spec implementers and application
writers. Failure points include loss of contact with components managing the
life cycle of LRAs and of participants. Application writers need to know
how to associate work with an LRA context so that the correct work
can be compensated for even after JVM or node crashes.
Likewise infrastructure components may become unavailable and state must
survive system failures. The specification is not prescriptive about how
an implementation achieves resiliency provided that it obeys the requirements
of the specification as laid out in this document.

include::release_notes.asciidoc[]

[[appendix-1]]
== Appendix 1: Selected Javadoc API Descriptions

=== LRA Annotation
[[source-LRA]]
----
include::{sourcedir}/org/eclipse/microprofile/lra/annotation/ws/rs/LRA.java[LRA]
----
<<<

=== Leave Annotation
[[source-Leave]]
----
include::{sourcedir}/org/eclipse/microprofile/lra/annotation/ws/rs/Leave.java[Leave]
----
<<<

=== Compensate Annotation
[[source-Compensate]]
----
include::{sourcedir}/org/eclipse/microprofile/lra/annotation/Compensate.java[Compensate]
----
<<<

=== Complete Annotation
[[source-Complete]]
----
include::{sourcedir}/org/eclipse/microprofile/lra/annotation/Complete.java[Leave]
----
<<<

=== Status Annotation
[[source-Status]]
----
include::{sourcedir}/org/eclipse/microprofile/lra/annotation/Status.java/[Status]
----
<<<

=== ParticipantStatus
[[source-ParticipantStatus]]
----
include::{sourcedir}/org/eclipse/microprofile/lra/annotation/ParticipantStatus.java/[ParticipantStatus]
----
<<<
